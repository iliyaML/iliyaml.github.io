<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-500.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><link rel=stylesheet href=/main.5a6da61787dd33a1f4266a84356b6bddb654307deead4955e92a35222a9ea082df264aa3d900cbd28a47bf139cbac4d6504566a6d330e46d959e92faa5df6f86.css integrity="sha512-Wm2mF4fdM6H0JmqENWtr3bZUMH3urUlV6So1IiqeoILfJkqj2QDL0opHvxOcusTWUEVmptMw5G2VnpL6pd9vhg==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>Week 1 Part 2 - Pre-training and Scaling Laws | iliyaML</title><meta name=description content="Week 1 Part 2 - Pre-training and Scaling Laws"><link rel=canonical href=/notes/nlp/generative-ai-with-llms/week-1-part-2/><meta property="og:locale" content><meta property="og:type" content="article"><meta property="og:title" content="Week 1 Part 2 - Pre-training and Scaling Laws"><meta property="og:description" content="Week 1 Part 2 - Pre-training and Scaling Laws"><meta property="og:url" content="/notes/nlp/generative-ai-with-llms/week-1-part-2/"><meta property="og:site_name" content="iliyaML"><meta property="article:published_time" content="2023-05-23T13:59:39+01:00"><meta property="article:modified_time" content="2023-05-23T13:59:39+01:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content><meta name=twitter:creator content><meta name=twitter:title content="Week 1 Part 2 - Pre-training and Scaling Laws"><meta name=twitter:description content="Week 1 Part 2 - Pre-training and Scaling Laws"><meta name=twitter:card content="summary"><meta name=twitter:image:alt content="Week 1 Part 2 - Pre-training and Scaling Laws"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Person","@id":"/#/schema/person/1","name":"","url":"/","sameAs":[],"image":{"@type":"ImageObject","@id":"/#/schema/image/1","url":"/\u003cnil\u003e","width":null,"height":null,"caption":""}},{"@type":"WebSite","@id":"/#/schema/website/1","url":"/","name":"iliyaML","description":"Hi, I’m Iliya 👋","publisher":{"@id":"/#/schema/person/1"}},{"@type":"WebPage","@id":"/notes/nlp/generative-ai-with-llms/week-1-part-2/","url":"/notes/nlp/generative-ai-with-llms/week-1-part-2/","name":"Week 1 Part 2 - Pre-training and Scaling Laws","description":"Week 1 Part 2 - Pre-training and Scaling Laws","isPartOf":{"@id":"/#/schema/website/1"},"about":{"@id":"/#/schema/person/1"},"datePublished":"2023-05-23T13:59:39CET","dateModified":"2023-05-23T13:59:39CET","breadcrumb":{"@id":"/notes/nlp/generative-ai-with-llms/week-1-part-2/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"/notes/nlp/generative-ai-with-llms/week-1-part-2/#/schema/image/2"},"inLanguage":"","potentialAction":[{"@type":"ReadAction","target":["/notes/nlp/generative-ai-with-llms/week-1-part-2/"]}]},{"@type":"BreadcrumbList","@id":"/notes/nlp/generative-ai-with-llms/week-1-part-2/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"/","url":"/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"/notesnlpgenerative-ai-with-llmsweek-1-part-2/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"/notes/nlp/generative-ai-with-llms/week-1-part-2/#/schema/image/2","url":null,"contentUrl":null,"caption":"Week 1 Part 2 - Pre-training and Scaling Laws"}]}]}</script><meta name=theme-color content="#fff"><link rel=icon href=/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=/site.webmanifest></head><body class="notes single"><div class=sticky-top><div class=header-bar></div><header class="navbar navbar-expand-lg navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/ aria-label=iliyaML>iliyaML</a>
<button class="btn btn-link order-0 ms-auto d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasExample aria-controls=offcanvasExample><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-more-horizontal"><circle cx="12" cy="12" r="1"/><circle cx="19" cy="12" r="1"/><circle cx="5" cy="12" r="1"/></svg></button><div class="offcanvas offcanvas-start d-lg-none" tabindex=-1 id=offcanvasExample aria-labelledby=offcanvasExampleLabel><div class=header-bar></div><div class=offcanvas-header><h5 class=offcanvas-title id=offcanvasExampleLabel>Browse notes</h5><button type=button class=btn-close data-bs-dismiss=offcanvas aria-label=Close></button></div><div class=offcanvas-body><aside class="doks-sidebar mt-n3"><nav id=doks-docs-nav aria-label="Tertiary navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-091fa9121c047db1dd48c3e2ab5f3c91 aria-expanded=false>
Machine Learning</button><div class=collapse id=section-091fa9121c047db1dd48c3e2ab5f3c91><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/notes/machine-learning/k-nearest-neighbors/>K-Nearest Neighbors (KNN)</a></li><li><a class="docs-link rounded" href=/notes/machine-learning/linear-regression/>Linear Regression</a></li><li><a class="docs-link rounded" href=/notes/machine-learning/logistic-regression/>Logistic Regression</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-6a68b6412b3d8a605c374d3c59e02694 aria-expanded=false>
Deep Learning</button><div class=collapse id=section-6a68b6412b3d8a605c374d3c59e02694><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/notes/deep-learning/neural-networks/>Neural Networks</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-85587c49afa2ea2adacd4bbcdb57d064 aria-expanded=true>
NLP</button><div class="collapse show" id=section-85587c49afa2ea2adacd4bbcdb57d064><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/notes/nlp/papers/>Papers</a></li><li><a class="docs-link rounded" href=/notes/nlp/attention-is-all-you-need/>Attention is All You Need (2017)</a></li><li><a class="docs-link rounded" href=/notes/nlp/state-of-gpt-2023/>State of GPT (2023)</a></li><li class="my-1 ms-3"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-d275029ac7b5f661dae7a2b707f60c0e aria-expanded=true>
Generative AI with Large Langauge Models</button><div class="collapse show" id=section-d275029ac7b5f661dae7a2b707f60c0e><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/notes/nlp/generative-ai-with-llms/introduction/>Introduction</a></li><li><a class="docs-link rounded" href=/notes/nlp/generative-ai-with-llms/week-1-part-1/>Week 1 Part 1 - Introduction to LLMs and the Generative AI Project Lifecycle</a></li><li><a class="docs-link rounded" href=/notes/nlp/generative-ai-with-llms/transformers-architecture/>Week 1 Part 1 - Transformers Architecture</a></li><li><a class="docs-link rounded active" href=/notes/nlp/generative-ai-with-llms/week-1-part-2/>Week 1 Part 2 - Pre-training and Scaling Laws</a></li><li><a class="docs-link rounded" href=/notes/nlp/generative-ai-with-llms/week-1-research-papers/>Week 1 - Research Papers</a></li><li><a class="docs-link rounded" href=/notes/nlp/generative-ai-with-llms/week-2-research-papers/>Week 2 - Research Papers</a></li><li><a class="docs-link rounded" href=/notes/nlp/generative-ai-with-llms/week-2-part-1/>Week 2 Part 1 - Fine-tuning LLMs with Instruction</a></li><li><a class="docs-link rounded" href=/notes/nlp/generative-ai-with-llms/week-2-part-2/>Week 2 Part 2 - Parameter Efficient Fine-tuning</a></li><li><a class="docs-link rounded" href=/notes/nlp/generative-ai-with-llms/week-3-part-1/>Week 3 Part 1 - Reinforcement Learning from Human Feedback</a></li><li><a class="docs-link rounded" href=/notes/nlp/generative-ai-with-llms/week-3-part-2/>Week 3 Part 2 - LLM-powered Applications</a></li><li><a class="docs-link rounded" href=/notes/nlp/generative-ai-with-llms/week-3-research-papers/>Week 3 - Research Papers</a></li><li><a class="docs-link rounded" href=/notes/nlp/generative-ai-with-llms/course-conclusion/>Course Conclusion</a></li></ul></div></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-c33e404a441c6ba9648f88af3c68a1ca aria-expanded=false>
Statistics</button><div class=collapse id=section-c33e404a441c6ba9648f88af3c68a1ca><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/notes/statistics/introduction/>Introduction</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-89320dbd4e0a792bc1676fde2d5bccfc aria-expanded=false>
DSA</button><div class=collapse id=section-89320dbd4e0a792bc1676fde2d5bccfc><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/notes/dsa/data-structures-and-algorithms/>Data Structures & Algorithms</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-98bf5c1a28c1981bf8d74d4bc73ceaab aria-expanded=false>
System Design</button><div class=collapse id=section-98bf5c1a28c1981bf8d74d4bc73ceaab><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li class="my-1 ms-3"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-0460583622f03a52d7693094d6fa2452 aria-expanded=false>
Concepts</button><div class=collapse id=section-0460583622f03a52d7693094d6fa2452><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/notes/system-design/concepts/basics/>Basics</a></li><li><a class="docs-link rounded" href=/notes/system-design/concepts/20-concepts/>20 Concepts</a></li><li><a class="docs-link rounded" href=/notes/system-design/concepts/25-golden-rules/>25 Golden Rules</a></li><li><a class="docs-link rounded" href=/notes/system-design/concepts/key-steps/>Key Steps</a></li></ul></div></li><li class="my-1 ms-3"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-1afa74da05ca145d3418aad9af510109 aria-expanded=false>
Design</button><div class=collapse id=section-1afa74da05ca145d3418aad9af510109><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/notes/system-design/design/url-shortener/>URL Shortener</a></li><li><a class="docs-link rounded" href=/notes/system-design/design/short-media-sharing-platform/>Short Media Sharing Platform</a></li><li><a class="docs-link rounded" href=/notes/system-design/design/video-streaming-platform/>Video Streaming Platform</a></li></ul></div></li></ul></div></li></ul></nav></aside></div></div><button class="btn btn-menu order-2 d-block d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/>iliyaML</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class=nav-item><a class="nav-link ps-0 py-1" href=/about/>About</a></li><li class=nav-item><a class="nav-link ps-0 py-1 active" href=/notes/nlp/generative-ai-with-llms/introduction/>Notes</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id=search class="form-control is-search" type=search placeholder=Search... aria-label=Search... autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=https://github.com/iliyaML><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-lg-none">GitHub</small></a></li><li class=nav-item><a class="nav-link social-link" href=https://www.linkedin.com/in/iliya-mohamad-lokman><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-linkedin"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg><small class="ms-2 d-lg-none">LinkedIn</small></a></li></ul><hr class="text-black-50 my-4 d-lg-none"><button id=mode class="btn btn-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></div></div></nav></header></div><div class=container-xxl><aside class=doks-sidebar><nav id=doks-docs-nav class="collapse d-lg-none" aria-label="Tertiary navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-091fa9121c047db1dd48c3e2ab5f3c91 aria-expanded=false>
Machine Learning</button><div class=collapse id=section-091fa9121c047db1dd48c3e2ab5f3c91><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/notes/machine-learning/k-nearest-neighbors/>K-Nearest Neighbors (KNN)</a></li><li><a class="docs-link rounded" href=/notes/machine-learning/linear-regression/>Linear Regression</a></li><li><a class="docs-link rounded" href=/notes/machine-learning/logistic-regression/>Logistic Regression</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-6a68b6412b3d8a605c374d3c59e02694 aria-expanded=false>
Deep Learning</button><div class=collapse id=section-6a68b6412b3d8a605c374d3c59e02694><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/notes/deep-learning/neural-networks/>Neural Networks</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-85587c49afa2ea2adacd4bbcdb57d064 aria-expanded=true>
NLP</button><div class="collapse show" id=section-85587c49afa2ea2adacd4bbcdb57d064><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/notes/nlp/papers/>Papers</a></li><li><a class="docs-link rounded" href=/notes/nlp/attention-is-all-you-need/>Attention is All You Need (2017)</a></li><li><a class="docs-link rounded" href=/notes/nlp/state-of-gpt-2023/>State of GPT (2023)</a></li><li class="my-1 ms-3"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-d275029ac7b5f661dae7a2b707f60c0e aria-expanded=true>
Generative AI with Large Langauge Models</button><div class="collapse show" id=section-d275029ac7b5f661dae7a2b707f60c0e><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/notes/nlp/generative-ai-with-llms/introduction/>Introduction</a></li><li><a class="docs-link rounded" href=/notes/nlp/generative-ai-with-llms/week-1-part-1/>Week 1 Part 1 - Introduction to LLMs and the Generative AI Project Lifecycle</a></li><li><a class="docs-link rounded" href=/notes/nlp/generative-ai-with-llms/transformers-architecture/>Week 1 Part 1 - Transformers Architecture</a></li><li><a class="docs-link rounded active" href=/notes/nlp/generative-ai-with-llms/week-1-part-2/>Week 1 Part 2 - Pre-training and Scaling Laws</a></li><li><a class="docs-link rounded" href=/notes/nlp/generative-ai-with-llms/week-1-research-papers/>Week 1 - Research Papers</a></li><li><a class="docs-link rounded" href=/notes/nlp/generative-ai-with-llms/week-2-research-papers/>Week 2 - Research Papers</a></li><li><a class="docs-link rounded" href=/notes/nlp/generative-ai-with-llms/week-2-part-1/>Week 2 Part 1 - Fine-tuning LLMs with Instruction</a></li><li><a class="docs-link rounded" href=/notes/nlp/generative-ai-with-llms/week-2-part-2/>Week 2 Part 2 - Parameter Efficient Fine-tuning</a></li><li><a class="docs-link rounded" href=/notes/nlp/generative-ai-with-llms/week-3-part-1/>Week 3 Part 1 - Reinforcement Learning from Human Feedback</a></li><li><a class="docs-link rounded" href=/notes/nlp/generative-ai-with-llms/week-3-part-2/>Week 3 Part 2 - LLM-powered Applications</a></li><li><a class="docs-link rounded" href=/notes/nlp/generative-ai-with-llms/week-3-research-papers/>Week 3 - Research Papers</a></li><li><a class="docs-link rounded" href=/notes/nlp/generative-ai-with-llms/course-conclusion/>Course Conclusion</a></li></ul></div></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-c33e404a441c6ba9648f88af3c68a1ca aria-expanded=false>
Statistics</button><div class=collapse id=section-c33e404a441c6ba9648f88af3c68a1ca><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/notes/statistics/introduction/>Introduction</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-89320dbd4e0a792bc1676fde2d5bccfc aria-expanded=false>
DSA</button><div class=collapse id=section-89320dbd4e0a792bc1676fde2d5bccfc><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/notes/dsa/data-structures-and-algorithms/>Data Structures & Algorithms</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-98bf5c1a28c1981bf8d74d4bc73ceaab aria-expanded=false>
System Design</button><div class=collapse id=section-98bf5c1a28c1981bf8d74d4bc73ceaab><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li class="my-1 ms-3"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-0460583622f03a52d7693094d6fa2452 aria-expanded=false>
Concepts</button><div class=collapse id=section-0460583622f03a52d7693094d6fa2452><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/notes/system-design/concepts/basics/>Basics</a></li><li><a class="docs-link rounded" href=/notes/system-design/concepts/20-concepts/>20 Concepts</a></li><li><a class="docs-link rounded" href=/notes/system-design/concepts/25-golden-rules/>25 Golden Rules</a></li><li><a class="docs-link rounded" href=/notes/system-design/concepts/key-steps/>Key Steps</a></li></ul></div></li><li class="my-1 ms-3"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-1afa74da05ca145d3418aad9af510109 aria-expanded=false>
Design</button><div class=collapse id=section-1afa74da05ca145d3418aad9af510109><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/notes/system-design/design/url-shortener/>URL Shortener</a></li><li><a class="docs-link rounded" href=/notes/system-design/design/short-media-sharing-platform/>Short Media Sharing Platform</a></li><li><a class="docs-link rounded" href=/notes/system-design/design/video-streaming-platform/>Video Streaming Platform</a></li></ul></div></li></ul></div></li></ul></nav></aside></div><div class="wrap container-xxl" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar d-none d-lg-block"><nav class=docs-links aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-091fa9121c047db1dd48c3e2ab5f3c91 aria-expanded=false>
Machine Learning</button><div class=collapse id=section-091fa9121c047db1dd48c3e2ab5f3c91><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/notes/machine-learning/k-nearest-neighbors/>K-Nearest Neighbors (KNN)</a></li><li><a class="docs-link rounded" href=/notes/machine-learning/linear-regression/>Linear Regression</a></li><li><a class="docs-link rounded" href=/notes/machine-learning/logistic-regression/>Logistic Regression</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-6a68b6412b3d8a605c374d3c59e02694 aria-expanded=false>
Deep Learning</button><div class=collapse id=section-6a68b6412b3d8a605c374d3c59e02694><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/notes/deep-learning/neural-networks/>Neural Networks</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-85587c49afa2ea2adacd4bbcdb57d064 aria-expanded=true>
NLP</button><div class="collapse show" id=section-85587c49afa2ea2adacd4bbcdb57d064><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/notes/nlp/papers/>Papers</a></li><li><a class="docs-link rounded" href=/notes/nlp/attention-is-all-you-need/>Attention is All You Need (2017)</a></li><li><a class="docs-link rounded" href=/notes/nlp/state-of-gpt-2023/>State of GPT (2023)</a></li><li class="my-1 ms-3"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-d275029ac7b5f661dae7a2b707f60c0e aria-expanded=true>
Generative AI with Large Langauge Models</button><div class="collapse show" id=section-d275029ac7b5f661dae7a2b707f60c0e><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/notes/nlp/generative-ai-with-llms/introduction/>Introduction</a></li><li><a class="docs-link rounded" href=/notes/nlp/generative-ai-with-llms/week-1-part-1/>Week 1 Part 1 - Introduction to LLMs and the Generative AI Project Lifecycle</a></li><li><a class="docs-link rounded" href=/notes/nlp/generative-ai-with-llms/transformers-architecture/>Week 1 Part 1 - Transformers Architecture</a></li><li><a class="docs-link rounded active" href=/notes/nlp/generative-ai-with-llms/week-1-part-2/>Week 1 Part 2 - Pre-training and Scaling Laws</a></li><li><a class="docs-link rounded" href=/notes/nlp/generative-ai-with-llms/week-1-research-papers/>Week 1 - Research Papers</a></li><li><a class="docs-link rounded" href=/notes/nlp/generative-ai-with-llms/week-2-research-papers/>Week 2 - Research Papers</a></li><li><a class="docs-link rounded" href=/notes/nlp/generative-ai-with-llms/week-2-part-1/>Week 2 Part 1 - Fine-tuning LLMs with Instruction</a></li><li><a class="docs-link rounded" href=/notes/nlp/generative-ai-with-llms/week-2-part-2/>Week 2 Part 2 - Parameter Efficient Fine-tuning</a></li><li><a class="docs-link rounded" href=/notes/nlp/generative-ai-with-llms/week-3-part-1/>Week 3 Part 1 - Reinforcement Learning from Human Feedback</a></li><li><a class="docs-link rounded" href=/notes/nlp/generative-ai-with-llms/week-3-part-2/>Week 3 Part 2 - LLM-powered Applications</a></li><li><a class="docs-link rounded" href=/notes/nlp/generative-ai-with-llms/week-3-research-papers/>Week 3 - Research Papers</a></li><li><a class="docs-link rounded" href=/notes/nlp/generative-ai-with-llms/course-conclusion/>Course Conclusion</a></li></ul></div></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-c33e404a441c6ba9648f88af3c68a1ca aria-expanded=false>
Statistics</button><div class=collapse id=section-c33e404a441c6ba9648f88af3c68a1ca><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/notes/statistics/introduction/>Introduction</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-89320dbd4e0a792bc1676fde2d5bccfc aria-expanded=false>
DSA</button><div class=collapse id=section-89320dbd4e0a792bc1676fde2d5bccfc><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/notes/dsa/data-structures-and-algorithms/>Data Structures & Algorithms</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-98bf5c1a28c1981bf8d74d4bc73ceaab aria-expanded=false>
System Design</button><div class=collapse id=section-98bf5c1a28c1981bf8d74d4bc73ceaab><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li class="my-1 ms-3"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-0460583622f03a52d7693094d6fa2452 aria-expanded=false>
Concepts</button><div class=collapse id=section-0460583622f03a52d7693094d6fa2452><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/notes/system-design/concepts/basics/>Basics</a></li><li><a class="docs-link rounded" href=/notes/system-design/concepts/20-concepts/>20 Concepts</a></li><li><a class="docs-link rounded" href=/notes/system-design/concepts/25-golden-rules/>25 Golden Rules</a></li><li><a class="docs-link rounded" href=/notes/system-design/concepts/key-steps/>Key Steps</a></li></ul></div></li><li class="my-1 ms-3"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-1afa74da05ca145d3418aad9af510109 aria-expanded=false>
Design</button><div class=collapse id=section-1afa74da05ca145d3418aad9af510109><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/notes/system-design/design/url-shortener/>URL Shortener</a></li><li><a class="docs-link rounded" href=/notes/system-design/design/short-media-sharing-platform/>Short Media Sharing Platform</a></li><li><a class="docs-link rounded" href=/notes/system-design/design/video-streaming-platform/>Video Streaming Platform</a></li></ul></div></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=d-xl-none><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type=button data-bs-toggle=collapse data-bs-target=#onThisPage aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></span></button><div class=collapse id=onThisPage><div class="card card-body mt-3 py-1"><div class=page-links><nav id=TableOfContents><ul><li><a href=#notes>Notes</a></li><li><a href=#pre-training-large-language-models>Pre-training Large Language Models</a><ul><li><a href=#stage-1-of-generative-ai-project-lifecycle---select>Stage 1 of Generative AI Project Lifecycle - Select</a></li><li><a href=#model-cards>Model Cards</a></li><li><a href=#model-architectures-and-pre-training-objectives>Model Architectures and Pre-training Objectives</a></li><li><a href=#transformer-variants>Transformer Variants</a></li><li><a href=#autoencoding-models>Autoencoding Models</a></li><li><a href=#autoregressive-models>Autoregressive Models</a></li><li><a href=#sequence-to-sequence-models>Sequence-to-Sequence Models</a></li><li><a href=#model-summary>Model Summary</a></li><li><a href=#the-significance-of-scale-task-ability>The Significance of Scale: Task Ability</a></li></ul></li><li><a href=#computational-challenges-of-training-llms>Computational Challenges of Training LLMs</a><ul><li><a href=#approximate-gpu-ram-needed-to-store-1b-parameters>Approximate GPU RAM Needed to Store 1B Parameters</a></li><li><a href=#additional-gpu-ram-needed-to-train-1-b-parameters>Additional GPU RAM Needed to Train 1 B Parameters</a></li><li><a href=#quantization>Quantization</a></li><li><a href=#quantization-pi-in-fp32>Quantization: PI in FP32</a></li><li><a href=#quantization-fp16>Quantization: FP16</a></li><li><a href=#quantization-bfloat16>Quantization: BFLOAT16</a></li><li><a href=#quantization-int8>Quantization: INT8</a></li><li><a href=#quantization-summary>Quantization: Summary</a></li><li><a href=#visualization-quantization>Visualization: Quantization</a></li><li><a href=#gpu-ram-needed-to-train-larger-models>GPU RAM Needed to Train Larger Models</a></li></ul></li><li><a href=#optional-efficient-multi-gpu-compute-strategies>Optional: Efficient Multi-GPU Compute Strategies</a><ul><li><a href=#distributed-data-parallel-ddp>Distributed Data Parallel (DDP)</a></li><li><a href=#fully-sharded-data-parallel-fsdp>Fully Sharded Data Parallel (FSDP)</a></li><li><a href=#memory-usage-in-ddp>Memory Usage in DDP</a></li><li><a href=#zero-redundancy-optimizer>Zero Redundancy Optimizer</a></li><li><a href=#visualization-distributed-data-parallel>Visualization: Distributed Data Parallel</a></li><li><a href=#visualization-fully-sharded-data-parallel>Visualization: Fully Sharded Data Parallel</a></li><li><a href=#sharding-factor>Sharding Factor</a></li><li><a href=#impact-of-using-fsdp>Impact of Using FSDP</a></li></ul></li><li><a href=#scaling-laws-and-compute-optimal-methods>Scaling Laws and Compute-Optimal Methods</a><ul><li><a href=#scaling-choices-for-pre-training>Scaling Choices for Pre-training</a></li><li><a href=#unit-of-compute>Unit of Compute</a></li><li><a href=#number-of-petaflops-days-to-pre-train-various-llms>Number of PetaFLOP/s-days to Pre-train Various LLMs</a></li><li><a href=#compute-budget-vs-model-performance>Compute Budget vs Model Performance</a></li><li><a href=#dataset-size-and-model-size-vs-performance>Dataset Size and Model Size vs Performance</a></li><li><a href=#chinchilla-paper-training-compute-optimal-large-language-models>Chinchilla Paper: Training Compute-Optimal Large Language Models</a></li><li><a href=#compute-optimal-models>Compute Optimal Models</a></li><li><a href=#chinchilla-scaling-laws-for-model-and-dataset-size>Chinchilla Scaling Laws for Model and Dataset Size</a></li><li><a href=#model-size-vs-time>Model Size vs Time</a></li></ul></li><li><a href=#pre-training-for-domain-adaptation>Pre-training for Domain Adaptation</a><ul><li><a href=#legal-language>Legal Language</a></li><li><a href=#medical-language>Medical Language</a></li><li><a href=#bloomberggpt-domain-adapatation-for-finance>BloombergGPT: Domain Adapatation for Finance</a></li><li><a href=#scaling-laws>Scaling Laws</a></li><li><a href=#key-takeways>Key Takeways</a></li></ul></li><li><a href=#reading-domain-specific-training-bloomberggpt>Reading: Domain-Specific Training: BloombergGPT</a></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#notes>Notes</a></li><li><a href=#pre-training-large-language-models>Pre-training Large Language Models</a><ul><li><a href=#stage-1-of-generative-ai-project-lifecycle---select>Stage 1 of Generative AI Project Lifecycle - Select</a></li><li><a href=#model-cards>Model Cards</a></li><li><a href=#model-architectures-and-pre-training-objectives>Model Architectures and Pre-training Objectives</a></li><li><a href=#transformer-variants>Transformer Variants</a></li><li><a href=#autoencoding-models>Autoencoding Models</a></li><li><a href=#autoregressive-models>Autoregressive Models</a></li><li><a href=#sequence-to-sequence-models>Sequence-to-Sequence Models</a></li><li><a href=#model-summary>Model Summary</a></li><li><a href=#the-significance-of-scale-task-ability>The Significance of Scale: Task Ability</a></li></ul></li><li><a href=#computational-challenges-of-training-llms>Computational Challenges of Training LLMs</a><ul><li><a href=#approximate-gpu-ram-needed-to-store-1b-parameters>Approximate GPU RAM Needed to Store 1B Parameters</a></li><li><a href=#additional-gpu-ram-needed-to-train-1-b-parameters>Additional GPU RAM Needed to Train 1 B Parameters</a></li><li><a href=#quantization>Quantization</a></li><li><a href=#quantization-pi-in-fp32>Quantization: PI in FP32</a></li><li><a href=#quantization-fp16>Quantization: FP16</a></li><li><a href=#quantization-bfloat16>Quantization: BFLOAT16</a></li><li><a href=#quantization-int8>Quantization: INT8</a></li><li><a href=#quantization-summary>Quantization: Summary</a></li><li><a href=#visualization-quantization>Visualization: Quantization</a></li><li><a href=#gpu-ram-needed-to-train-larger-models>GPU RAM Needed to Train Larger Models</a></li></ul></li><li><a href=#optional-efficient-multi-gpu-compute-strategies>Optional: Efficient Multi-GPU Compute Strategies</a><ul><li><a href=#distributed-data-parallel-ddp>Distributed Data Parallel (DDP)</a></li><li><a href=#fully-sharded-data-parallel-fsdp>Fully Sharded Data Parallel (FSDP)</a></li><li><a href=#memory-usage-in-ddp>Memory Usage in DDP</a></li><li><a href=#zero-redundancy-optimizer>Zero Redundancy Optimizer</a></li><li><a href=#visualization-distributed-data-parallel>Visualization: Distributed Data Parallel</a></li><li><a href=#visualization-fully-sharded-data-parallel>Visualization: Fully Sharded Data Parallel</a></li><li><a href=#sharding-factor>Sharding Factor</a></li><li><a href=#impact-of-using-fsdp>Impact of Using FSDP</a></li></ul></li><li><a href=#scaling-laws-and-compute-optimal-methods>Scaling Laws and Compute-Optimal Methods</a><ul><li><a href=#scaling-choices-for-pre-training>Scaling Choices for Pre-training</a></li><li><a href=#unit-of-compute>Unit of Compute</a></li><li><a href=#number-of-petaflops-days-to-pre-train-various-llms>Number of PetaFLOP/s-days to Pre-train Various LLMs</a></li><li><a href=#compute-budget-vs-model-performance>Compute Budget vs Model Performance</a></li><li><a href=#dataset-size-and-model-size-vs-performance>Dataset Size and Model Size vs Performance</a></li><li><a href=#chinchilla-paper-training-compute-optimal-large-language-models>Chinchilla Paper: Training Compute-Optimal Large Language Models</a></li><li><a href=#compute-optimal-models>Compute Optimal Models</a></li><li><a href=#chinchilla-scaling-laws-for-model-and-dataset-size>Chinchilla Scaling Laws for Model and Dataset Size</a></li><li><a href=#model-size-vs-time>Model Size vs Time</a></li></ul></li><li><a href=#pre-training-for-domain-adaptation>Pre-training for Domain Adaptation</a><ul><li><a href=#legal-language>Legal Language</a></li><li><a href=#medical-language>Medical Language</a></li><li><a href=#bloomberggpt-domain-adapatation-for-finance>BloombergGPT: Domain Adapatation for Finance</a></li><li><a href=#scaling-laws>Scaling Laws</a></li><li><a href=#key-takeways>Key Takeways</a></li></ul></li><li><a href=#reading-domain-specific-training-bloomberggpt>Reading: Domain-Specific Training: BloombergGPT</a></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9"><h1>Week 1 Part 2 - Pre-training and Scaling Laws</h1><p class=lead></p><nav class=d-xl-none aria-label="Quaternary navigation"><div class=d-xl-none><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type=button data-bs-toggle=collapse data-bs-target=#onThisPage aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></span></button><div class=collapse id=onThisPage><div class="card card-body mt-3 py-1"><div class=page-links><nav id=TableOfContents><ul><li><a href=#notes>Notes</a></li><li><a href=#pre-training-large-language-models>Pre-training Large Language Models</a><ul><li><a href=#stage-1-of-generative-ai-project-lifecycle---select>Stage 1 of Generative AI Project Lifecycle - Select</a></li><li><a href=#model-cards>Model Cards</a></li><li><a href=#model-architectures-and-pre-training-objectives>Model Architectures and Pre-training Objectives</a></li><li><a href=#transformer-variants>Transformer Variants</a></li><li><a href=#autoencoding-models>Autoencoding Models</a></li><li><a href=#autoregressive-models>Autoregressive Models</a></li><li><a href=#sequence-to-sequence-models>Sequence-to-Sequence Models</a></li><li><a href=#model-summary>Model Summary</a></li><li><a href=#the-significance-of-scale-task-ability>The Significance of Scale: Task Ability</a></li></ul></li><li><a href=#computational-challenges-of-training-llms>Computational Challenges of Training LLMs</a><ul><li><a href=#approximate-gpu-ram-needed-to-store-1b-parameters>Approximate GPU RAM Needed to Store 1B Parameters</a></li><li><a href=#additional-gpu-ram-needed-to-train-1-b-parameters>Additional GPU RAM Needed to Train 1 B Parameters</a></li><li><a href=#quantization>Quantization</a></li><li><a href=#quantization-pi-in-fp32>Quantization: PI in FP32</a></li><li><a href=#quantization-fp16>Quantization: FP16</a></li><li><a href=#quantization-bfloat16>Quantization: BFLOAT16</a></li><li><a href=#quantization-int8>Quantization: INT8</a></li><li><a href=#quantization-summary>Quantization: Summary</a></li><li><a href=#visualization-quantization>Visualization: Quantization</a></li><li><a href=#gpu-ram-needed-to-train-larger-models>GPU RAM Needed to Train Larger Models</a></li></ul></li><li><a href=#optional-efficient-multi-gpu-compute-strategies>Optional: Efficient Multi-GPU Compute Strategies</a><ul><li><a href=#distributed-data-parallel-ddp>Distributed Data Parallel (DDP)</a></li><li><a href=#fully-sharded-data-parallel-fsdp>Fully Sharded Data Parallel (FSDP)</a></li><li><a href=#memory-usage-in-ddp>Memory Usage in DDP</a></li><li><a href=#zero-redundancy-optimizer>Zero Redundancy Optimizer</a></li><li><a href=#visualization-distributed-data-parallel>Visualization: Distributed Data Parallel</a></li><li><a href=#visualization-fully-sharded-data-parallel>Visualization: Fully Sharded Data Parallel</a></li><li><a href=#sharding-factor>Sharding Factor</a></li><li><a href=#impact-of-using-fsdp>Impact of Using FSDP</a></li></ul></li><li><a href=#scaling-laws-and-compute-optimal-methods>Scaling Laws and Compute-Optimal Methods</a><ul><li><a href=#scaling-choices-for-pre-training>Scaling Choices for Pre-training</a></li><li><a href=#unit-of-compute>Unit of Compute</a></li><li><a href=#number-of-petaflops-days-to-pre-train-various-llms>Number of PetaFLOP/s-days to Pre-train Various LLMs</a></li><li><a href=#compute-budget-vs-model-performance>Compute Budget vs Model Performance</a></li><li><a href=#dataset-size-and-model-size-vs-performance>Dataset Size and Model Size vs Performance</a></li><li><a href=#chinchilla-paper-training-compute-optimal-large-language-models>Chinchilla Paper: Training Compute-Optimal Large Language Models</a></li><li><a href=#compute-optimal-models>Compute Optimal Models</a></li><li><a href=#chinchilla-scaling-laws-for-model-and-dataset-size>Chinchilla Scaling Laws for Model and Dataset Size</a></li><li><a href=#model-size-vs-time>Model Size vs Time</a></li></ul></li><li><a href=#pre-training-for-domain-adaptation>Pre-training for Domain Adaptation</a><ul><li><a href=#legal-language>Legal Language</a></li><li><a href=#medical-language>Medical Language</a></li><li><a href=#bloomberggpt-domain-adapatation-for-finance>BloombergGPT: Domain Adapatation for Finance</a></li><li><a href=#scaling-laws>Scaling Laws</a></li><li><a href=#key-takeways>Key Takeways</a></li></ul></li><li><a href=#reading-domain-specific-training-bloomberggpt>Reading: Domain-Specific Training: BloombergGPT</a></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#notes>Notes</a></li><li><a href=#pre-training-large-language-models>Pre-training Large Language Models</a><ul><li><a href=#stage-1-of-generative-ai-project-lifecycle---select>Stage 1 of Generative AI Project Lifecycle - Select</a></li><li><a href=#model-cards>Model Cards</a></li><li><a href=#model-architectures-and-pre-training-objectives>Model Architectures and Pre-training Objectives</a></li><li><a href=#transformer-variants>Transformer Variants</a></li><li><a href=#autoencoding-models>Autoencoding Models</a></li><li><a href=#autoregressive-models>Autoregressive Models</a></li><li><a href=#sequence-to-sequence-models>Sequence-to-Sequence Models</a></li><li><a href=#model-summary>Model Summary</a></li><li><a href=#the-significance-of-scale-task-ability>The Significance of Scale: Task Ability</a></li></ul></li><li><a href=#computational-challenges-of-training-llms>Computational Challenges of Training LLMs</a><ul><li><a href=#approximate-gpu-ram-needed-to-store-1b-parameters>Approximate GPU RAM Needed to Store 1B Parameters</a></li><li><a href=#additional-gpu-ram-needed-to-train-1-b-parameters>Additional GPU RAM Needed to Train 1 B Parameters</a></li><li><a href=#quantization>Quantization</a></li><li><a href=#quantization-pi-in-fp32>Quantization: PI in FP32</a></li><li><a href=#quantization-fp16>Quantization: FP16</a></li><li><a href=#quantization-bfloat16>Quantization: BFLOAT16</a></li><li><a href=#quantization-int8>Quantization: INT8</a></li><li><a href=#quantization-summary>Quantization: Summary</a></li><li><a href=#visualization-quantization>Visualization: Quantization</a></li><li><a href=#gpu-ram-needed-to-train-larger-models>GPU RAM Needed to Train Larger Models</a></li></ul></li><li><a href=#optional-efficient-multi-gpu-compute-strategies>Optional: Efficient Multi-GPU Compute Strategies</a><ul><li><a href=#distributed-data-parallel-ddp>Distributed Data Parallel (DDP)</a></li><li><a href=#fully-sharded-data-parallel-fsdp>Fully Sharded Data Parallel (FSDP)</a></li><li><a href=#memory-usage-in-ddp>Memory Usage in DDP</a></li><li><a href=#zero-redundancy-optimizer>Zero Redundancy Optimizer</a></li><li><a href=#visualization-distributed-data-parallel>Visualization: Distributed Data Parallel</a></li><li><a href=#visualization-fully-sharded-data-parallel>Visualization: Fully Sharded Data Parallel</a></li><li><a href=#sharding-factor>Sharding Factor</a></li><li><a href=#impact-of-using-fsdp>Impact of Using FSDP</a></li></ul></li><li><a href=#scaling-laws-and-compute-optimal-methods>Scaling Laws and Compute-Optimal Methods</a><ul><li><a href=#scaling-choices-for-pre-training>Scaling Choices for Pre-training</a></li><li><a href=#unit-of-compute>Unit of Compute</a></li><li><a href=#number-of-petaflops-days-to-pre-train-various-llms>Number of PetaFLOP/s-days to Pre-train Various LLMs</a></li><li><a href=#compute-budget-vs-model-performance>Compute Budget vs Model Performance</a></li><li><a href=#dataset-size-and-model-size-vs-performance>Dataset Size and Model Size vs Performance</a></li><li><a href=#chinchilla-paper-training-compute-optimal-large-language-models>Chinchilla Paper: Training Compute-Optimal Large Language Models</a></li><li><a href=#compute-optimal-models>Compute Optimal Models</a></li><li><a href=#chinchilla-scaling-laws-for-model-and-dataset-size>Chinchilla Scaling Laws for Model and Dataset Size</a></li><li><a href=#model-size-vs-time>Model Size vs Time</a></li></ul></li><li><a href=#pre-training-for-domain-adaptation>Pre-training for Domain Adaptation</a><ul><li><a href=#legal-language>Legal Language</a></li><li><a href=#medical-language>Medical Language</a></li><li><a href=#bloomberggpt-domain-adapatation-for-finance>BloombergGPT: Domain Adapatation for Finance</a></li><li><a href=#scaling-laws>Scaling Laws</a></li><li><a href=#key-takeways>Key Takeways</a></li></ul></li><li><a href=#reading-domain-specific-training-bloomberggpt>Reading: Domain-Specific Training: BloombergGPT</a></li></ul></nav></div></nav><p>These notes were developed using lectures/material/transcripts from the <a href=https://www.deeplearning.ai/courses/generative-ai-with-llms/>DeepLearning.AI & AWS - Generative AI with Large Language Models</a> course</p><h2 id=notes>Notes <a href=#notes class=anchor aria-hidden=true>#</a></h2><ul><li>Pre-training Large Language Models<ul><li>Stage 1 of Generative AI Project Lifecycle - Select<ul><li>Work with an existing Foundation model or train your own model</li></ul></li><li>Model cards - model details, uses, bias, risks, limitations, training details and evaluation</li><li>Model Architectures and Pre-training Objectives<ul><li>LLMs encode a deep statistical representation of language</li><li>The model’s pre-training phase - the model learns from vast amounts of unstructured textual data (petabytes of text)</li><li>In this self-supervised learning step, the model internalizes the patterns and structures present in the language</li><li>Transformer Variants<ul><li>Autoencoding (encoder only) models - trained using Masked Language Modeling (MLM), denoising objective<ul><li>Build bi-directional representations of the input sequence, meaning that the model has an understanding of the full context of a token and not just of the words that come before</li><li>Tasks: Sentiment Analysis, Named Entity Recognition (NER), Sentence/Word/Token Classification</li><li>Models: BERT, RoBERTa</li></ul></li><li>Autoregressive (decoder only) models - trained using Causal Language Modeling (CLM)<ul><li>Mask the input sequence and can only see the input tokens leading up to the token in question, the model has no knowledge of the end of the sentence. The context is unidirectional</li><li>By learning to predict the next token from a vast number of examples, the model builds up a statistical representation of language</li><li>Tasks: Text Generation, Emergent Abilities (Zero Shot Inference, etc.)</li><li>Models: GPT, BLOOM</li></ul></li><li>Sequence-to-Sequence (encoder-decoder) models<ul><li>Exact details of the pre-training objective vary from model to model</li><li>Tasks: Translation, Text Summarization, and Question Answering</li><li>Models: T5, BART</li></ul></li></ul></li><li>The Significance of Scale: Task Ability<ul><li>The larger a model, the more likely it is to work as you needed to without additional in-context learning or further training</li></ul></li></ul></li></ul></li><li>Computational Challenges of Training LLMs<ul><li>Challenges: OutOfMemoryError - CUDA out of memory</li><li>Require sufficient memory to store all this:<ol><li>Weights: 4 bytes per parameter</li><li>Two Adam optimizer states: 8 bytes per parameter</li><li>Gradients: 4 bytes per parameter</li><li>Activations and Temporary variables needed by your functions: 8 bytes per parameter</li></ol><ul><li>Total: 4 bytes per parameter + 20 extra bytes per parameter</li></ul></li><li>Quantization - reduce the memory requirement by reducing their precision<ul><li>Memory to store a number<ul><li>Bits</li><li>Exponent</li><li>Fraction (referred to as Mantissa)</li></ul></li><li>Data Types<ul><li>FP32: 4 bytes of memory</li><li>FP16: 2 bytes of memory</li><li>BFLOAT16: 2 bytes of memory<ul><li>Hybrid between half precision FP16 and full precision FP32</li><li>Downside: not well suited for integer calculations</li></ul></li><li>INT8: 1 byte of memory</li><li>INT4</li></ul></li><li>Quantization statistically projects the original 32-bit floating point numbers into a lower precision space, using scaling factors calculated based on the range of the original 32-bit floating point numbers</li><li>Quantization-Aware Training (QAT) learns the quantization scaling factors during training</li><li>Note: Quantization does not reduce the number of model parameters</li></ul></li><li>Approximate GPU RAM Needed to Store and Train 1B Parameters<ul><li>Memory needed to store model: 4GB @32-bit full precision<ul><li>2GB @16-bit half precision</li><li>1GB @8-bit precision</li></ul></li><li>Memory needed to train model: 80GB @32-bit full precision<ul><li>40GB @16-bit half precision</li><li>20GB @8-bit precision</li></ul></li><li>80GB is the maximum memory for the NVIDIA A100 GPU</li></ul></li><li>As the model sizes get larger, you will need to split your model across multiple GPUs for training</li></ul></li><li>Optional: Efficient Multi-GPU Compute Strategies<ul><li>When to Use Distributed Compute<ol><li>Model too big for single GPU</li><li>Model fits on GPU, train data in parallel</li></ol></li><li>PyTorch Implementation</li><li>Distributed Data Parallel (DDP) - Model fits on a single GPU<ul><li>Requires that your model weights and all of the additional parameters, gradients, and optimizer states that are needed for training, fit onto a single GPU</li><li>Copies your model onto each GPU and sends batches of data to each of the GPUs in parallel. Each data-set is processed in parallel and then a synchronization step combines the results of each GPU, which in turn updates the model on each GPU, which is always identical across chips</li></ul></li><li>Fully Sharded Data Parallel (FSDP) - Model no longer fits on a single GPU<ul><li>Model Sharding</li><li>FSDP is motivated by the “ZERO” paper - zero data overlap between GPUs</li><li>sharding factor - configure the level of sharding to manage the trade-off between performance and memory utilization<ul><li>1 = removes the sharding and replicated the full model similar to DDP</li><li>Maximum number of GPUs = full sharding</li><li>Anywhere in between = hybrid sharding</li></ul></li><li>Can use FSDP for both small and large models and seamlessly scale your model training across multiple GPUs</li></ul></li></ul></li><li>Scaling Laws and Compute-Optimal Models<ul><li>To determine how big models need to be, learn about research that explore the relationship between<ul><li>Model size</li><li>Training</li><li>Configuration</li><li>Performance</li></ul></li><li>Scaling Choices for Pre-training<ul><li>Goal: maximize the model&rsquo;s performance of its learning objective, which is minimizing the loss when predicting tokens</li><li>Options to achieve better performance:<ol><li>Increasing the size of the dataset you train your model on</li><li>Increasing the number of parameters in your model</li></ol></li><li>Constraint: compute budget (number of GPUs, training time, cost)</li></ul></li><li>Unit of Compute<ul><li>“petaFLOP/s-day” = a measurement of the number of floating point operations performed at rate of 1 petaFLOP per second for one day</li><li>1 petaFLOP corresponds to one quadrillion floating point operations per second</li><li>In the context of training transformers, 1 petaFLOP per second day is approximately equivalent to eight NVIDIA V100 GPUs, operating at full efficiency for one full day</li></ul></li><li>Compute Budget vs Model Performance<ul><li>Increase your compute budget to achieve better model performance</li><li>In practice however, the compute resources you have available for training will generally be a hard constraint set by factors such as<ul><li>the hardware you have access to,</li><li>the time available for training and</li><li>the financial budget of the project</li></ul></li></ul></li><li>Dataset Size and Model Size vs Model Performance<ul><li>As the volume of training data increases, the performance of the model continues to improve</li><li>As the model size increases in size, the test loss decreases indicating better performance</li></ul></li><li>Chinchilla Paper: Training Compute-Optimal Large Language Models<ul><li>Goal: to find the optimal number of parameters and volume of training data for a given compute budget</li><li>Findings<ol><li>Very large models may be over-parameterized and under-trained</li><li>Smaller models trained on more data could perform as well as large model</li></ol></li></ul></li><li>Chinchilla Scaling Laws for Model and Dataset Size<ul><li>The optimal training dataset size for a given model is about 20 times larger than the number of parameters in the model</li><li>The compute optimal Chinchilla model outperforms non-compute optimal models such as GPT-3 on a large range of downstream evaluation tasks</li></ul></li><li>Model Size vs Time<ul><li>Expect to see smaller models developed to achieve better results than larger models trained in a non-optimal way</li></ul></li></ul></li><li>Pre-training for Domain Adaptation<ul><li>Highly specialized domains: Law, Medical, Finance, Science</li><li>BloombergGPT: Domain Adaptation for Finance<ul><li>Scaling Laws</li></ul></li></ul></li><li>Reading: Domain-Specific Training: BloombergGPT<ul><li>A large Decoder-only model</li><li>Pre-trained on finance data</li><li>Used Chinchilla Scaling Laws to guide the number of parameters in the model and volume of training data (tokens)</li></ul></li></ul><hr><h2 id=pre-training-large-language-models>Pre-training Large Language Models <a href=#pre-training-large-language-models class=anchor aria-hidden=true>#</a></h2><h3 id=stage-1-of-generative-ai-project-lifecycle---select>Stage 1 of Generative AI Project Lifecycle - Select <a href=#stage-1-of-generative-ai-project-lifecycle---select class=anchor aria-hidden=true>#</a></h3><ul><li>Once you have scoped out your use case, and determined how you&rsquo;ll need the LLM to work within your application, your next step is to select a model to work with. Your first choice will be to either work with an existing model, or train your own from scratch. There are specific circumstances where training your own model from scratch might be advantageous, and you&rsquo;ll learn about those later in this lesson. In general, however, you&rsquo;ll begin the process of developing your application using an existing foundation model</li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled.png alt=Untitled></p><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%201.png alt=Untitled></p><h3 id=model-cards>Model Cards <a href=#model-cards class=anchor aria-hidden=true>#</a></h3><ul><li>Describe important details including the best use cases for each model, how it was trained, and known limitations</li><li>The exact model that you&rsquo;d choose will depend on the details of the task you need to carry out</li><li>Variance of the transformer model architecture are suited to different language tasks, largely because of differences in how the models are trained</li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%202.png alt=Untitled></p><h3 id=model-architectures-and-pre-training-objectives>Model Architectures and Pre-training Objectives <a href=#model-architectures-and-pre-training-objectives class=anchor aria-hidden=true>#</a></h3><ul><li>Take a high-level look at the initial training process for LLMs</li><li>This phase is often referred to as pre-training.</li><li>As you saw in Lesson 1, LLMs encode a deep statistical representation of language.</li><li>This understanding is developed during the model’s pre-training phase when the model learns from vast amounts of unstructured textual data.</li><li>This can be gigabytes, terabytes, and even petabytes of text.</li><li>This data is pulled from many sources, including scrapes off the Internet and corpora of texts that have been assembled specifically for training language models.</li><li>In this self-supervised learning step, the model internalizes the patterns and structures present in the language.</li><li>These patterns then enable the model to complete its training objective, which depends on the architecture of the model, as you&rsquo;ll see shortly.</li><li>During pre-training, the model weights get updated to minimize the loss of the training objective.</li><li>The encoder generates an embedding or vector representation for each token.</li><li>Pre-training also requires a large amount of compute and the use of GPUs.</li><li>Note, when you scrape training data from public sites such as the Internet, you often need to process the data to increase quality, address bias, and remove other harmful content.<ul><li>As a result of this data quality curation, often only 1-3% of tokens are used for pre-training.</li><li>You should consider this when you estimate how much data you need to collect if you decide to pre-train your own model</li></ul></li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%203.png alt=Untitled></p><h3 id=transformer-variants>Transformer Variants <a href=#transformer-variants class=anchor aria-hidden=true>#</a></h3><ol><li>Encoder Only Models</li><li>Encoder Decoder Models</li><li>Decoder Models</li></ol><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%204.png alt=Untitled></p><h3 id=autoencoding-models>Autoencoding Models <a href=#autoencoding-models class=anchor aria-hidden=true>#</a></h3><ul><li>Encoder-only models are also known as Autoencoding models, and they are pre-trained using masked language modeling. Here, tokens in the input sequence or randomly mask, and the training objective is to predict the mask tokens in order to reconstruct the original sentence. This is also called a denoising objective. Autoencoding models build bi-directional representations of the input sequence, meaning that the model has an understanding of the full context of a token and not just of the words that come before. Encoder-only models are ideally suited to task that benefit from this bi-directional contexts. You can use them to carry out sentence classification tasks, for example, sentiment analysis or token-level tasks like named entity recognition or word classification.<ul><li>Some well-known examples of an autoencoder model are BERT and RoBERTa</li></ul></li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%205.png alt=Untitled></p><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%206.png alt=Untitled></p><h3 id=autoregressive-models>Autoregressive Models <a href=#autoregressive-models class=anchor aria-hidden=true>#</a></h3><ul><li>let&rsquo;s take a look at decoder-only or autoregressive models, which are pre-trained using causal language modeling. Here, the training objective is to predict the next token based on the previous sequence of tokens. Predicting the next token is sometimes called full language modeling by researchers. Decoder-based autoregressive models, mask the input sequence and can only see the input tokens leading up to the token in question. The model has no knowledge of the end of the sentence. The model then iterates over the input sequence one by one to predict the following token. In contrast to the encoder architecture, this means that the context is unidirectional. By learning to predict the next token from a vast number of examples, the model builds up a statistical representation of language. Models of this type make use of the decoder component off the original architecture without the encoder. Decoder-only models are often used for text generation, although larger decoder-only models show strong zero-shot inference abilities, and can often perform a range of tasks well.<ul><li>Well known examples of decoder-based autoregressive models are GPT and BLOOM</li></ul></li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%207.png alt=Untitled></p><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%208.png alt=Untitled></p><h3 id=sequence-to-sequence-models>Sequence-to-Sequence Models <a href=#sequence-to-sequence-models class=anchor aria-hidden=true>#</a></h3><ul><li>The final variation of the transformer model is the sequence-to-sequence model that uses both the encoder and decoder parts off the original transformer architecture. The exact details of the pre-training objective vary from model to model. A popular sequence-to-sequence model T5, pre-trains the encoder using span corruption, which masks random sequences of input tokens. Those mass sequences are then replaced with a unique Sentinel token, shown here as x. Sentinel tokens are special tokens added to the vocabulary, but do not correspond to any actual word from the input text. The decoder is then tasked with reconstructing the mask token sequences auto-regressively. The output is the Sentinel token followed by the predicted tokens. You can use sequence-to-sequence models for translation, summarization, and question-answering. They are generally useful in cases where you have a body of texts as both input and output.<ul><li>Besides T5, which you&rsquo;ll use in the labs in this course, another well-known encoder-decoder model is BART</li></ul></li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%209.png alt=Untitled></p><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2010.png alt=Untitled></p><h3 id=model-summary>Model Summary <a href=#model-summary class=anchor aria-hidden=true>#</a></h3><ul><li>To summarize, here&rsquo;s a quick comparison of the different model architectures and the targets off the pre-training objectives.<ul><li>Autoencoding models are pre-trained using masked language modeling. They correspond to the encoder part of the original transformer architecture, and are often used with sentence classification or token classification.</li><li>Autoregressive models are pre-trained using causal language modeling. Models of this type make use of the decoder component of the original transformer architecture, and often used for text generation.</li><li>Sequence-to-sequence models use both the encoder and decoder part off the original transformer architecture. The exact details of the pre-training objective vary from model to model. The T5 model is pre-trained using span corruption. Sequence-to-sequence models are often used for translation, summarization, and question-answering.</li></ul></li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2011.png alt=Untitled></p><h3 id=the-significance-of-scale-task-ability>The Significance of Scale: Task Ability <a href=#the-significance-of-scale-task-ability class=anchor aria-hidden=true>#</a></h3><ul><li>One additional thing to keep in mind is that larger models of any architecture are typically more capable of carrying out their tasks well.</li><li>Researchers have found that the larger a model, the more likely it is to work as you needed to without additional in-context learning or further training</li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2012.png alt=Untitled></p><ul><li>This observed trend of increased model capability with size has driven the development of larger and larger models in recent years. This growth has been fueled by inflection points and research, such as<ul><li>the introduction of the highly scalable transformer architecture,</li><li>access to massive amounts of data for training, and</li><li>the development of more powerful compute resources</li></ul></li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2013.png alt=Untitled></p><ul><li>This steady increase in model size actually led some researchers to hypothesize the existence of a new Moore&rsquo;s law for LLMs. Like them, you may be asking,<ul><li>Can we just keep adding parameters to increase performance and make models smarter?</li><li>Where could this model growth lead?</li></ul></li><li>While this may sound great, it turns out that training these enormous models is difficult and very expensive, so much so that it may be infeasible to continuously train larger and larger models.</li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2014.png alt=Untitled></p><hr><h2 id=computational-challenges-of-training-llms>Computational Challenges of Training LLMs <a href=#computational-challenges-of-training-llms class=anchor aria-hidden=true>#</a></h2><ul><li>OutOfMemoryError: CUDA out of memory.</li><li>One of the most common issues you still counter when you try to train large language models is running out of memory.</li><li>If you&rsquo;ve ever tried training or even just loading your model on NVIDIA GPUs, this error message might look familiar.</li><li>CUDA, short for Compute Unified Device Architecture, is a collection of libraries and tools developed for Nvidia GPUs.</li><li>Libraries such as PyTorch and TensorFlow use CUDA to boost performance on matrix multiplication and other operations common to deep learning.</li><li>You&rsquo;ll encounter these out-of-memory issues because most LLMs are huge, and require a ton of memory to store and train all of their parameters.</li></ul><h3 id=approximate-gpu-ram-needed-to-store-1b-parameters>Approximate GPU RAM Needed to Store 1B Parameters <a href=#approximate-gpu-ram-needed-to-store-1b-parameters class=anchor aria-hidden=true>#</a></h3><ul><li>A single parameter is typically represented by a 32-bit float, which is a way computers represent real numbers.</li><li>You&rsquo;ll see more details about how numbers gets stored in this format shortly.</li><li>A 32-bit float takes up four bytes of memory.</li><li>So to store one billion parameters you&rsquo;ll need four bytes times one billion parameters, or four gigabyte of GPU RAM at 32-bit full precision.</li><li>This is a lot of memory, and note, if only accounted for the memory to store the model weights so far.</li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2015.png alt=Untitled></p><h3 id=additional-gpu-ram-needed-to-train-1-b-parameters>Additional GPU RAM Needed to Train 1 B Parameters <a href=#additional-gpu-ram-needed-to-train-1-b-parameters class=anchor aria-hidden=true>#</a></h3><ul><li>If you want to train the model, you&rsquo;ll have to plan for additional components that use GPU memory during training. These include<ol><li>two Adam optimizer states,</li><li>gradients,</li><li>activations, and</li><li>temporary variables needed by your functions.</li></ol></li><li>This can easily lead to 20 extra bytes of memory per model parameter.</li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2016.png alt=Untitled></p><ul><li>In fact, to account for all of these overhead during training, you&rsquo;ll actually require approximately 20 times the amount of GPU RAM that the model weights alone take up.</li><li>To train a one billion parameter model at 32-bit full precision, you&rsquo;ll need approximately 80 gigabyte of GPU RAM.</li><li>This is definitely too large for consumer hardware, and even challenging for hardware used in data centers, if you want to train with a single processor.</li><li>Eighty gigabyte is the memory capacity of a single NVIDIA A100 GPU, a common processor used for machine learning tasks in the Cloud.</li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2017.png alt=Untitled></p><p>What options do you have to reduce the memory required for training?</p><ul><li>One technique that you can use to reduce the memory is called Quantization.</li></ul><h3 id=quantization>Quantization <a href=#quantization class=anchor aria-hidden=true>#</a></h3><ul><li>The main idea here is that you reduce the memory required to store the weights of your model by reducing their precision from 32-bit floating point numbers to 16-bit floating point numbers, or eight-bit integer numbers. The corresponding data types used in deep learning frameworks and libraries are<ul><li>FP32 for 32-bit full position,</li><li>FP16, or BFLOAT16 for 16-bit half precision, and</li><li>INT8 eight-bit integers.</li></ul></li><li>The range of numbers you can represent with FP32 goes from approximately 3x<em>10^-38 to 3x</em>10^38.</li><li>By default, model weights, activations, and other model parameters are stored in FP32.</li><li>Quantization statistically projects the original 32-bit floating point numbers into a lower precision space, using scaling factors calculated based on the range of the original 32-bit floating point numbers.</li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2018.png alt=Untitled></p><h3 id=quantization-pi-in-fp32>Quantization: PI in FP32 <a href=#quantization-pi-in-fp32 class=anchor aria-hidden=true>#</a></h3><ul><li>Suppose you want to store a PI to six decimal places in different positions. Floating point numbers are stored as a series of bits zeros and ones.</li><li>The 32 bits to store numbers in full precision with FP32 consist of<ul><li>one bit for the sign where zero indicates a positive number, and one a negative number. Then</li><li>eight bits for the exponent of the number, and</li><li>23 bits representing the fraction of the number. The fraction is also referred to as the mantissa, or significand. It represents the precision bits off the number.</li></ul></li><li>If you convert the 32-bit floating point value back to a decimal value, you notice the slight loss in precision. For reference, here&rsquo;s the real value of PI to 19 decimal places.</li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2019.png alt=Untitled></p><h3 id=quantization-fp16>Quantization: FP16 <a href=#quantization-fp16 class=anchor aria-hidden=true>#</a></h3><ul><li>Now, let&rsquo;s see what happens if you project this FP32 representation of PI into the FP16, 16-bit lower precision space. The 16 bits consists of<ul><li>one bit for the sign, as you saw for FP32, but now FP16 only assigns</li><li>five bits to represent the exponent and</li><li>10 bits to represent the fraction.</li></ul></li><li>Therefore, the range of numbers you can represent with FP16 is vastly smaller from negative 65,504 to positive 65,504.</li><li>The original FP32 value gets projected to 3.140625 in the 16-bit space.</li><li>Notice that you lose some precision with this projection.</li><li>There are only six places after the decimal point now.</li><li>You&rsquo;ll find that this loss in precision is acceptable in most cases because you&rsquo;re trying to optimize for memory footprint.</li><li>Storing a value in FP32 requires four bytes of memory.</li><li>In contrast, storing a value on FP16 requires only two bytes of memory, so with quantization you have reduced the memory requirement by half.</li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2020.png alt=Untitled></p><h3 id=quantization-bfloat16>Quantization: BFLOAT16 <a href=#quantization-bfloat16 class=anchor aria-hidden=true>#</a></h3><ul><li>The AI research community has explored ways to optimize 16-bit quantization.</li><li>One datatype in particular BFLOAT16, has recently become a popular alternative to FP16.</li><li>BFLOAT16, short for Brain Floating Point Format developed at Google Brain has become a popular choice in deep learning.</li><li>Many LLMs, including FLAN-T5, have been pre-trained with BFLOAT16.</li><li>BFLOAT16 or BF16 is a hybrid between half precision FP16 and full precision FP32.</li><li>BF16 significantly helps with training stability and is supported by newer GPU&rsquo;s such as NVIDIA&rsquo;s A100.</li><li>BFLOAT16 is often described as a truncated 32-bit float, as it captures the full dynamic range of the full 32-bit float, that uses only 16-bits.</li><li>BFLOAT16 uses the full eight bits to represent the exponent, but truncates the fraction to just seven bits.</li><li>This not only saves memory, but also increases model performance by speeding up calculations.</li><li>The downside is that BF16 is not well suited for integer calculations, but these are relatively rare in deep learning.</li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2021.png alt=Untitled></p><h3 id=quantization-int8>Quantization: INT8 <a href=#quantization-int8 class=anchor aria-hidden=true>#</a></h3><ul><li>For completeness let&rsquo;s have a look at what happens if you quantize PI from the 32-bit into the even lower precision eight bit space. If you use<ul><li>one bit for the sign INT8</li><li>values are represented by the remaining seven bits.</li></ul></li><li>This gives you a range to represent numbers from negative 128 to positive 127 and unsurprisingly PI gets projected two or three in the 8-bit lower precision space.</li><li>This brings new memory requirement down from originally four bytes to just one byte, but obviously results in a pretty dramatic loss of precision.</li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2022.png alt=Untitled></p><h3 id=quantization-summary>Quantization: Summary <a href=#quantization-summary class=anchor aria-hidden=true>#</a></h3><ul><li>Remember that the goal of quantization is to reduce the memory required to store and train models by reducing the precision off the model weights.</li><li>Quantization statistically projects the original 32-bit floating point numbers into lower precision spaces using scaling factors calculated based on the range of the original 32-bit floats.</li><li>Modern deep learning frameworks and libraries support Quantization-Aware Training (QAT), which learns the quantization scaling factors during the training process. The details of this process are beyond the scope of this course.</li><li>But you&rsquo;ve seen the key point here, that you can use quantization to reduce the memory footprint off the model during training.</li><li>BFLOAT16 has become a popular choice of precision in deep learning as it maintains the dynamic range of FP32, but reduces the memory footprint by half.</li><li>Many LLMs, including FLAN-T5, have been pre-trained with BFOLAT16.</li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2023.png alt=Untitled></p><h3 id=visualization-quantization>Visualization: Quantization <a href=#visualization-quantization class=anchor aria-hidden=true>#</a></h3><ul><li>Let&rsquo;s return to the challenge of fitting models into GPU memory and take a look at the impact quantization can have</li><li>By applying quantization, you can reduce your memory consumption required to store the model parameters down to only two gigabyte using 16-bit half precision of 50% saving and you could further reduce the memory footprint by another 50% by representing the model parameters as eight bit integers, which requires only one gigabyte of GPU RAM.</li><li>Note that in all these cases you still have a model with one billion parameters. As you can see, the circles representing the models are the same size</li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2024.png alt=Untitled></p><ul><li>Quantization will give you the same degree of savings when it comes to training.</li><li>As you heard earlier, you&rsquo;ll quickly hit the limit of a single NVIDIA A100 GPU with 80 gigabytes of memory, when you try to train a one billion parameter model at 32-bit full precision.</li><li>You&rsquo;ll need to consider using either 16-bit or eight bit quantization if you want to train on a single GPU</li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2025.png alt=Untitled></p><h3 id=gpu-ram-needed-to-train-larger-models>GPU RAM Needed to Train Larger Models <a href=#gpu-ram-needed-to-train-larger-models class=anchor aria-hidden=true>#</a></h3><ul><li>Remember, many models now have sizes in excess of 50 billion or even 100 billion parameters, meaning you&rsquo;d need up to 500 times more memory capacity to train them, tens of thousands of gigabytes.</li><li>These enormous models dwarf the one billion parameter model we&rsquo;ve been considering, shown here to scale on the left</li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2026.png alt=Untitled></p><ul><li>As models scale beyond a few billion parameters, it becomes impossible to train them on a single GPU.</li><li>Instead, you&rsquo;ll need to turn to distributed computing techniques while you train your model across multiple GPUs.</li><li>This could require access to hundreds of GPUs, which is very expensive, another reason why you won&rsquo;t pre-train your own model from scratch most of the time</li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2027.png alt=Untitled></p><ul><li>However, an additional training process called Fine-tuning also require storing all training parameters in memory and it&rsquo;s very likely you&rsquo;ll want to fine tune a model at some point.</li></ul><hr><h2 id=optional-efficient-multi-gpu-compute-strategies>Optional: Efficient Multi-GPU Compute Strategies <a href=#optional-efficient-multi-gpu-compute-strategies class=anchor aria-hidden=true>#</a></h2><ul><li>Need to scale your model training efforts beyond a single GPU.</li><li>Need to use multi GPU compute strategies when your model becomes too big to fit in a single GPU</li><li>But even if your model does fit onto a single GPU, there are benefits to using multiple GPUs to speed up your training</li><li>It’s useful to know how to distribute compute across GPUs even when you&rsquo;re working with a small model</li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2028.png alt=Untitled></p><p>Let&rsquo;s discuss how you can carry out this scaling across multiple GPUs in an efficient way.</p><h3 id=distributed-data-parallel-ddp>Distributed Data Parallel (DDP) <a href=#distributed-data-parallel-ddp class=anchor aria-hidden=true>#</a></h3><p>Model still fits on a single GPU</p><ul><li>The first step in scaling model training is to distribute large data-sets across multiple GPUs and process these batches of data in parallel.</li><li>A popular implementation of this model replication technique is PyTorch’s Distributed Data Parallel (DDP)<ul><li>DDP copies your model onto each GPU and sends batches of data to each of the GPUs in parallel.</li><li>Each data-set is processed in parallel and then a synchronization step combines the results of each GPU, which in turn updates the model on each GPU, which is always identical across chips.</li><li>This implementation allows parallel computations across all GPUs that results in faster training.</li></ul></li><li>Note: DDP requires that your model weights and all of the additional parameters, gradients, and optimizer states that are needed for training, fit onto a single GPU.</li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2029.png alt=Untitled></p><ul><li>If your model is too big for this, you should look into another technique called Model Sharding.</li></ul><h3 id=fully-sharded-data-parallel-fsdp>Fully Sharded Data Parallel (FSDP) <a href=#fully-sharded-data-parallel-fsdp class=anchor aria-hidden=true>#</a></h3><p>Model no longer fits on a single GPU</p><ul><li>A popular implementation of modal sharding is PyTorch’s Fully Sharded Data Parallel (FSDP)</li><li>FSDP is motivated by a paper published by researchers at Microsoft in 2019 that proposed a technique called ZeRO.</li><li>ZeRO stands for Zero Redundancy Optimizer and the goal of ZeRO is to optimize memory by distributing or sharding model states across GPUs with ZeRO data overlap.<ul><li>This allows you to scale model training across GPUs when your model doesn&rsquo;t fit in the memory of a single chip.</li></ul></li></ul><p>Let&rsquo;s take a quick look at how ZeRO works before coming back to FSDP.</p><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2030.png alt=Untitled></p><ul><li>Looked at all of the memory components required for training LLMs, the largest memory requirement was for<ol><li>the optimizer states, which take up twice as much space as the weights, followed by</li><li>weights themselves and</li><li>the gradients.</li></ol></li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2031.png alt=Untitled></p><h3 id=memory-usage-in-ddp>Memory Usage in DDP <a href=#memory-usage-in-ddp class=anchor aria-hidden=true>#</a></h3><ul><li>Let&rsquo;s represent the parameters as this blue box, the gradients and yellow and the optimizer states in green.</li><li>One limitation off the model replication strategy that I showed before is that you need to keep a full model copy on each GPU, which leads to redundant memory consumption. You are storing the same numbers on every GPU.</li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2032.png alt=Untitled></p><h3 id=zero-redundancy-optimizer>Zero Redundancy Optimizer <a href=#zero-redundancy-optimizer class=anchor aria-hidden=true>#</a></h3><ul><li>ZeRO, on the other hand, eliminates this redundancy by distributing also referred to as sharding the model parameters, gradients, and optimizer states across GPUs instead of replicating them.</li><li>At the same time, the communication overhead for a sinking model states stays close to that of the previously discussed DDP.</li><li>ZeRO offers three optimization stages.<ul><li>ZeRO Stage 1, shots only optimizer states across GPUs, this can reduce your memory footprint by up to a factor of four.</li><li>ZeRO Stage 2 also shots the gradients across chips. When applied together with Stage 1, this can reduce your memory footprint by up to eight times.</li><li>Finally, ZeRO Stage 3 shots all components including the model parameters across GPUs.</li></ul></li><li>When applied together with Stages 1 and 2, memory reduction is linear with a number of GPUs.<ul><li>For example, sharding across 64 GPUs could reduce your memory by a factor of 64.</li></ul></li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2033.png alt=Untitled></p><p>Let&rsquo;s apply this concept to the visualization of DDP and replace the LLM by the memory representation of model parameters, gradients, and optimizer states.</p><h3 id=visualization-distributed-data-parallel>Visualization: Distributed Data Parallel <a href=#visualization-distributed-data-parallel class=anchor aria-hidden=true>#</a></h3><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2034.png alt=Untitled></p><h3 id=visualization-fully-sharded-data-parallel>Visualization: Fully Sharded Data Parallel <a href=#visualization-fully-sharded-data-parallel class=anchor aria-hidden=true>#</a></h3><ul><li>When you use FSDP, you distribute the data across multiple GPUs as you saw happening in DDP.</li><li>But with FSDP, you also distributed or shard the model parameters, gradients, and optimize the states across the GPU nodes using one of the strategies specified in the ZeRO paper.</li><li>With this strategy, you can now work with models that are too big to fit on a single chip.</li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2035.png alt=Untitled></p><ul><li>In contrast to GDP, where each GPU has all of the model states required for processing each batch of data available locally, FSDP requires you to collect this data from all of the GPUs before the forward and backward pass.</li><li>Each CPU requests data from the other GPUs on-demand to materialize the sharded data into uncharted data for the duration of the operation.</li><li>After the operation, you release the uncharted non-local data back to the other GPUs as original sharded data You can also choose to keep it for future operations during backward pass for example.</li><li>Note, this requires more GPU RAM again, this is a typical performance versus memory trade-off decision.</li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2036.png alt=Untitled></p><ul><li>In the final step after the backward pass, FSDP is synchronizes the gradients across the GPUs in the same way they were for DDP.</li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2037.png alt=Untitled></p><h3 id=sharding-factor>Sharding Factor <a href=#sharding-factor class=anchor aria-hidden=true>#</a></h3><ul><li>Model Sharding as described with FSDP allows you to reduce your overall GPU memory utilization.</li><li>Optionally, you can specify that FSDP offloads part of the training computation to GPUs to further reduce your GPU memory utilization.</li><li>To manage the trade-off between performance and memory utilization, you can configure the level of sharding using FSDP is <strong>sharding factor</strong>.<ul><li>A sharding factor of one basically removes the sharding and replicates the full model similar to DDP.</li><li>If you set the sharding factor to the maximum number of available GPUs, you turn on full sharding.<ul><li>This has the most memory savings, but increases the communication volume between GPUs.</li></ul></li><li>Any sharding factor in-between enables hybrid sharding.</li></ul></li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2038.png alt=Untitled></p><h3 id=impact-of-using-fsdp>Impact of Using FSDP <a href=#impact-of-using-fsdp class=anchor aria-hidden=true>#</a></h3><ul><li>Let&rsquo;s take a look at how FSDP performs in comparison to DDP measured in teraflops per GPU.</li><li>These tests were performed using a maximum of 512 NVIDIA V100 GPUs, each with 80 gigabytes of memory.</li><li>Note, one teraflop corresponds to one trillion floating-point operations per second.</li><li>The first figure shows FSDP performance for different size T5 models.<ul><li>You can see the different performance numbers for FSDP, full sharding in blue, hybrid shard in orange and full replication in green.</li><li>For reference, DDP performance is shown in red.</li><li>For the first 25 models with 611 million parameters and 2.28 billion parameters, the performance of FSDP and DDP is similar.</li><li>Now, if you choose a model size beyond 2.28 billion, such as T5 with 11.3 billion parameters, DDP runs into the out-of-memory error.</li><li>FSDP on the other hand can easily handle models this size and achieve much higher teraflops when lowering the model&rsquo;s precision to 16-bit.</li></ul></li><li>The second figure shows 7% decrease in per GPU teraflops when increasing the number of GPUs from 8-512 for the 11 billion T5 model, plotted here using a batch size of 16 and orange and a batch size of eight in blue.<ul><li>As the model grows in size and is distributed across more and more GPUs, the increase in communication volume between chips starts to impact the performance, slowing down the computation.</li></ul></li><li>In summary, this shows that you can use FSDP for both small and large models and seamlessly scale your model training across multiple GPUs.</li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2039.png alt=Untitled></p><ul><li>The most important thing is to have a sense of how the data model parameters and training computations are shared across processes when training LLMs.</li><li>Given the expense and technical complexity of training models across GPUs, some researchers have been exploring ways to achieve better performance with smaller models.</li></ul><p>Question: Which of the following best describes the role of data parallelism in the context of training Large Language Models (LLMs) with GPUs?</p><p>Data parallelism allows for the use of multiple GPUs to process different parts of the same data simultaneously, speeding up training time.</p><p>Correct
Data parallelism is a strategy that splits the training data across multiple GPUs. Each GPU processes a different subset of the data simultaneously, which can greatly speed up the overall training time.</p><hr><h2 id=scaling-laws-and-compute-optimal-methods>Scaling Laws and Compute-Optimal Methods <a href=#scaling-laws-and-compute-optimal-methods class=anchor aria-hidden=true>#</a></h2><ul><li><p>Learn about research that has explored the relationship between</p><ul><li>model size,</li><li>training,</li><li>configuration and</li><li>performance</li></ul><p>in an effort to determine just how big models need to be</p></li></ul><h3 id=scaling-choices-for-pre-training>Scaling Choices for Pre-training <a href=#scaling-choices-for-pre-training class=anchor aria-hidden=true>#</a></h3><ul><li>Remember, the goal during pre-training is to maximize the model&rsquo;s performance of its learning objective, which is minimizing the loss when predicting tokens.</li><li>Two options you have to achieve better performance are<ol><li>increasing the size of the dataset you train your model on and</li><li>increasing the number of parameters in your model.</li></ol><ul><li>In theory, you could scale either of both of these quantities to improve performance.</li></ul></li><li>However, another issue to take into consideration is<ul><li>your compute budget which includes factors like the number of GPUs you have access to and</li><li>the time you have available for training models</li></ul></li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2040.png alt=Untitled></p><h3 id=unit-of-compute>Unit of Compute <a href=#unit-of-compute class=anchor aria-hidden=true>#</a></h3><ul><li>To help you understand some of the discussion ahead, let&rsquo;s first define a unit of compute that quantifies the required resources.</li><li>A petaFLOP per second-day is a measurement of the number of floating point operations performed at a rate of one petaFLOP per second, running for an entire day.</li><li>Note: one petaFLOP corresponds to one quadrillion floating point operations per second.</li><li>When specifically thinking about training transformers, one petaFLOP per second day is approximately equivalent to eight NVIDIA V100 GPUs, operating at full efficiency for one full day.</li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2041.png alt=Untitled></p><ul><li>If you have a more powerful processor that can carry out more operations at once, then a petaFLOP per second day requires fewer chips.<ul><li>For example, two NVIDIA A100 GPUs give equivalent compute to the eight V100 chips.</li></ul></li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2042.png alt=Untitled></p><h3 id=number-of-petaflops-days-to-pre-train-various-llms>Number of PetaFLOP/s-days to Pre-train Various LLMs <a href=#number-of-petaflops-days-to-pre-train-various-llms class=anchor aria-hidden=true>#</a></h3><ul><li>To give you an idea off the scale of these compute budgets, this chart shows a comparison off the petaFLOP per second days required to pre-train different variants of<ul><li>BERT and RoBERTa, which are both encoder only models,</li><li>T5 and encoder-decoder model and</li><li>GPT-3, which is a decoder only model.</li></ul></li><li>The difference between the models in each family is the number of parameters that were trained, ranging from a few hundred million for BERT base to 175 billion for the largest GPT-3 variant.</li><li>Note that the y-axis is logarithmic. Each increment vertically is a power of 10.</li><li>Here we see that T5 XL with three billion parameters required close to 100 petaFLOP per second days while the larger GPT-3 175 billion parameter model required approximately 3,700 petaFLOP per second days.</li><li>This chart makes it clear that a huge amount of computers required to train the largest models.</li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2043.png alt=Untitled></p><ul><li>You can see that bigger models take more compute resources to train and generally also require more data to achieve good performance.</li><li>It turns out that they are actually well-defined relationships between these three scaling choices.</li></ul><h3 id=compute-budget-vs-model-performance>Compute Budget vs Model Performance <a href=#compute-budget-vs-model-performance class=anchor aria-hidden=true>#</a></h3><ul><li>Researchers have explored the trade-offs between training dataset size, model size and compute budget. Here&rsquo;s a figure from a paper by researchers at OpenAI that explores the impact of compute budget on model performance.<ul><li>The y-axis is the test loss, which you can consider as a proxy for model performance where smaller values are better.</li><li>The x-axis is the compute budget in units of petaFLOP per second days.</li></ul></li><li>As you just saw, larger numbers can be achieved by either using more compute power or training for longer or both.</li><li>Each thin blue line here shows the model loss over a single training run. Looking at where the loss starts to decline more slowly for each run, reveals a clear relationship between the compute budget and the model&rsquo;s performance.</li><li>This can be approximated by a power-law relationship, shown by this pink line.</li><li>A power law is a mathematical relationship between two variables, where one is proportional to the other raised to some power.</li><li>When plotted on a graph where both axes are logarithmic, power-law relationships appear as straight lines.</li><li>The relationship here holds as long as model size and training dataset size don&rsquo;t inhibit the training process.</li><li>Taken at face value, this would suggest that you can just increase your compute budget to achieve better model performance.</li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2044.png alt=Untitled></p><h3 id=dataset-size-and-model-size-vs-performance>Dataset Size and Model Size vs Performance <a href=#dataset-size-and-model-size-vs-performance class=anchor aria-hidden=true>#</a></h3><ul><li>In practice however, the compute resources you have available for training will generally be a hard constraint set by factors such as<ul><li>the hardware you have access to,</li><li>the time available for training and</li><li>the financial budget of the project.</li></ul></li><li>If you hold your compute budget fixed, the two levers you have to improve your model&rsquo;s performance are<ul><li>the size of the training dataset and</li><li>the number of parameters in your model</li></ul></li><li>The OpenAI researchers found that these two quantities also show a power-law relationship with a test loss in the case where the other two variables are held fixed</li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2045.png alt=Untitled></p><ul><li>This is another figure from the paper exploring the impact of training dataset size on model performance.<ul><li>Here, the compute budget and model size are held fixed and the size of the training dataset is vary.</li><li>The graph shows that as the volume of training data increases, the performance of the model continues to improve.</li></ul></li><li>In the second graph, the compute budget and training dataset size are held constant. Models of varying numbers of parameters are trained.<ul><li>As the model increases in size, the test loss decreases indicating better performance.</li></ul></li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2046.png alt=Untitled></p><ul><li>At this point you might be asking, what&rsquo;s the ideal balance between these three quantities?</li><li>Well, it turns out a lot of people are interested in this question.</li><li>Both research and industry communities have published a lot of empirical data for pre-training compute optimal models</li></ul><h3 id=chinchilla-paper-training-compute-optimal-large-language-models>Chinchilla Paper: Training Compute-Optimal Large Language Models <a href=#chinchilla-paper-training-compute-optimal-large-language-models class=anchor aria-hidden=true>#</a></h3><ul><li>In a paper published in 2022, a group of researchers led by Jordan Hoffmann, Sebastian Borgeaud and Arthur Mensch carried out a detailed study of the performance of language models of various sizes and quantities of training data.</li><li>The goal was to find the optimal number of parameters and volume of training data for a given compute budget. The authors name the resulting compute optimal model, Chinchilla.</li><li>This paper is often referred to as the Chinchilla paper.</li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2047.png alt=Untitled></p><h3 id=compute-optimal-models>Compute Optimal Models <a href=#compute-optimal-models class=anchor aria-hidden=true>#</a></h3><ul><li>The Chinchilla paper hints that many of the 100 billion parameter large language models like GPT-3 may actually be <strong>over-parameterized</strong>, meaning they have more parameters than they need to achieve a good understanding of language and <strong>under-trained</strong> so that they would benefit from seeing more training data.</li><li>The authors hypothesized that smaller models may be able to achieve the same performance as much larger ones if they are trained on larger datasets</li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2048.png alt=Untitled></p><h3 id=chinchilla-scaling-laws-for-model-and-dataset-size>Chinchilla Scaling Laws for Model and Dataset Size <a href=#chinchilla-scaling-laws-for-model-and-dataset-size class=anchor aria-hidden=true>#</a></h3><ul><li>In this table, you can see a selection of models along with their size and information about the dataset they were trained on.</li><li>One important takeaway from the Chinchilla paper is that the optimal training dataset size for a given model is about 20 times larger than the number of parameters in the model.</li><li>Chinchilla was determined to be compute optimal.<ul><li>For a 70 billion parameter model, the ideal training dataset contains 1.4 trillion tokens or 20 times the number of parameters.</li></ul></li><li>The last three models in the table were trained on datasets that are smaller than the Chinchilla optimal size. These models may actually be under trained.</li><li>In contrast, LLaMA was trained on a dataset size of 1.4 trillion tokens, which is close to the Chinchilla recommended number.</li><li>Another important result from the paper is that the compute optimal Chinchilla model outperforms non-compute optimal models such as GPT-3 on a large range of downstream evaluation tasks</li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2049.png alt=Untitled></p><h3 id=model-size-vs-time>Model Size vs Time <a href=#model-size-vs-time class=anchor aria-hidden=true>#</a></h3><ul><li>With the results of the Chinchilla paper in hand teams have recently started to develop smaller models that achieved similar, if not better results than larger models that were trained in a non-optimal way.</li><li>Moving forward, you can probably expect to see a deviation from the bigger is always better trends of the last few years as more teams or developers like you start to optimize their model design.</li><li>The last model shown on this slide, BloombergGPT, is a really interesting model.<ul><li>It was trained in a compute optimal way following the Chinchilla loss and so achieves good performance with the size of 50 billion parameters</li></ul></li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2050.png alt=Untitled></p><p>It&rsquo;s also an interesting example of a situation where pre-training a model from scratch was necessary to achieve good task performance.</p><hr><h2 id=pre-training-for-domain-adaptation>Pre-training for Domain Adaptation <a href=#pre-training-for-domain-adaptation class=anchor aria-hidden=true>#</a></h2><ul><li>If your target domain uses vocabulary and language structures that are not commonly used in day to day language, you may need to perform domain adaptation to achieve good model performance.</li></ul><h3 id=legal-language>Legal Language <a href=#legal-language class=anchor aria-hidden=true>#</a></h3><ul><li>For example, imagine you&rsquo;re a developer building an app to help lawyers and paralegals summarize legal briefs. Legal writing makes use of very specific terms like <strong>mens rea</strong> in the first example and <strong>res judicata</strong> in the second.</li><li>These words are rarely used outside of the legal world, which means that they are unlikely to have appeared widely in the training text of existing LLMs. As a result, the models may have difficulty understanding these terms or using them correctly.</li><li>Another issue is that legal language sometimes uses everyday words in a different context, like <strong>consideration</strong> in the third example. Which has nothing to do with being nice, but instead refers to the main element of a contract that makes the agreement enforceable.</li></ul><h3 id=medical-language>Medical Language <a href=#medical-language class=anchor aria-hidden=true>#</a></h3><ul><li>For similar reasons, you may face challenges if you try to use an existing LLM in a medical application. Medical language contains many uncommon words to describe medical conditions and procedures. And these may not appear frequently in training datasets consisting of web scrapes and book texts. Some domains also use language in a highly idiosyncratic way.</li><li>This last example of medical language may just look like a string of random characters, but it&rsquo;s actually a shorthand used by doctors to write prescriptions. This text has a very clear meaning to a pharmacist, take one tablet by mouth four times a day, after meals and at bedtime</li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2051.png alt=Untitled></p><ul><li>Because models learn their vocabulary and understanding of language through the original pretraining task.</li><li>Pretraining your model from scratch will result in better models for highly specialized domains like law, medicine, finance or science</li></ul><h3 id=bloomberggpt-domain-adapatation-for-finance>BloombergGPT: Domain Adapatation for Finance <a href=#bloomberggpt-domain-adapatation-for-finance class=anchor aria-hidden=true>#</a></h3><ul><li>First announced in 2023 in a paper by Shijie Wu, Steven Lu, and colleagues at Bloomberg</li><li>BloombergGPT is an example of a large language model that has been pretrained for a specific domain, in this case, finance</li><li>The Bloomberg researchers chose to combine both finance data and general purpose tax data to pretrain a model that achieves best in class results on financial benchmarks, while also maintaining competitive performance on general purpose LLM benchmarks.<ul><li>As such, the researchers chose data consisting of 51% financial data and 49% public data.</li></ul></li><li>In their paper, the Bloomberg researchers describe the model architecture in more detail.</li><li>They also discuss how they started with a Chinchilla Scaling Laws for guidance and where they had to make tradeoffs</li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2052.png alt=Untitled></p><h3 id=scaling-laws>Scaling Laws <a href=#scaling-laws class=anchor aria-hidden=true>#</a></h3><ul><li>These two graphs compare a number of LLMs, including BloombergGPT, to scaling laws that have been discussed by researchers.<ul><li>On the left, the diagonal lines trace the optimal model size in billions of parameters for a range of compute budgets.</li><li>On the right, the lines trace the compute optimal training data set size measured in number of tokens.</li></ul></li><li>The dashed pink line on each graph indicates the compute budget that the Bloomberg team had available for training their new model.</li><li>The pink shaded regions correspond to the compute optimal scaling loss determined in the Chinchilla paper.</li><li>In terms of model size, you can see that BloombergGPT roughly follows the Chinchilla approach for the given compute budget of 1.3 million GPU hours, or roughly 230,000,000 petaflops.</li><li>The model is only a little bit above the pink shaded region, suggesting the number of parameters is fairly close to optimal.</li><li>However, the actual number of tokens used to pretrain BloombergGPT 569,000,000,000 is below the recommended Chinchilla value for the available compute budget.</li><li>The smaller than optimal training data set is due to the limited availability of financial domain data showing that real world constraints may force you to make trade offs when pretraining your own models</li></ul><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2053.png alt=Untitled></p><h3 id=key-takeways>Key Takeways <a href=#key-takeways class=anchor aria-hidden=true>#</a></h3><ul><li>Walked you through some of the common use cases for LLMs, such as essay writing, dialogue summarization and translation.</li><li>Gave a detailed presentation of the transformer architecture that powers these models.</li><li>Discussed some of the parameters you can use at inference time to influence the model&rsquo;s output.</li><li>Introduced to Generative AI Project Lifecycle that you can use to plan and guide your application development work.</li><li>Saw how models are trained on vast amounts of text data during an initial training phase called pretraining. This is where models develop their understanding of language.</li><li>Explored some of the computational challenges of training these models, which are significant. In practice, because of GPU memory limitations, you will almost always use some form of quantization when training your models.</li><li>Finished with a discussion of scaling laws that have been discovered for LLMs and how they can be used to design compute optimal models.</li></ul><p>Question: Which of the following statements about pretraining scaling laws are correct? Select all that apply:</p><p>Which of the following statements about pretraining scaling laws are correct? Select all that apply:</p><p><strong>To scale our model, we need to jointly increase dataset size and model size, or they can become a bottleneck for each other.</strong></p><p>Correct</p><p>For instance, while increasing dataset size is helpful, if we do not jointly improve the model size, it might not be able to capture value from the larger dataset.</p><p><strong>There is a relationship between model size (in number of parameters) and the optimal number of tokens to train the model with.</strong></p><p>Correct</p><p>This relationship is describe in the Chinchilla paper, that shows that many models might even be overparametrized according to the relationship they found.</p><p><strong>When measuring compute budget, we can use &ldquo;PetaFlops per second-Day&rdquo; as a metric.</strong></p><p>Correct</p><p>Petaflops per second-day is a useful measure for computing budget as it reflects the both hardware and time required to train the model.</p><hr><h2 id=reading-domain-specific-training-bloomberggpt>Reading: Domain-Specific Training: BloombergGPT <a href=#reading-domain-specific-training-bloomberggpt class=anchor aria-hidden=true>#</a></h2><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2054.png alt=Untitled></p><p><img class="img-fluid lazyload blur-up" src=https://raw.githubusercontent.com/iliyaML/hosting/main/generative-ai-with-llms/week-1-part-2/Untitled%2055.png alt=Untitled></p><ul><li>BloombergGPT - <a href=https://arxiv.org/abs/2303.17564>https://arxiv.org/abs/2303.17564</a><ul><li>a large Decoder-only language model</li><li>underwent pre-training using an extensive financial dataset to increase its understanding of finance and enabling it to generate finance-related natural language text.<ul><li>Dataset comprises of<ul><li>news articles</li><li>reports</li><li>market data</li></ul></li></ul></li><li>During the training of BloombergGPT, the authors used the Chinchilla Scaling Laws to guide the number of parameters in the model and the volume of training data, measured in tokens.</li><li>The recommendations of Chinchilla are represented by the lines Chinchilla-1, Chinchilla-2 and Chinchilla-3 in the image, and we can see that BloombergGPT is close to it.</li><li>While the recommended configuration for the team’s available training compute budget was 50 billion parameters and 1.4 trillion tokens, acquiring 1.4 trillion tokens of training data in the finance domain proved challenging.</li><li>Consequently, they constructed a dataset containing just 700 billion tokens, less than the compute-optimal value. Furthermore, due to early stopping, the training process terminated after processing 569 billion tokens.</li><li>The BloombergGPT project is a good illustration of pre-training a model for increased domain-specificity, and the challenges that may force trade-offs against compute-optimal model and training configurations.</li></ul></li></ul><div class="page-footer-meta d-flex flex-column flex-md-row justify-content-between"></div><div class="docs-navigation d-flex justify-content-between"><a href=/notes/nlp/generative-ai-with-llms/transformers-architecture/><div class="card my-1"><div class="card-body py-2">&larr; Week 1 Part 1 - Transformers Architecture</div></div></a><a class=ms-auto href=/notes/nlp/generative-ai-with-llms/week-1-research-papers/><div class="card my-1"><div class="card-body py-2">Week 1 - Research Papers &rarr;</div></div></a></div></main></div></div></div><script async src="https://www.googletagmanager.com/gtag/js?id=G-X0X8EQ5BBE"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-X0X8EQ5BBE")</script><footer class="footer text-muted"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>© 2023 <a class=text-muted href=/>iliyaML</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline></ul></div></div></div></footer><script src=/js/bootstrap.min.650aeec64c81d69d4c0850fc73c93da3f0330cec0a27772feed7f90f60baa5f47f1c45687d71914bdafd1c4e860d40f6dc08ede27a2f08431ff929c9a2d24621.js integrity="sha512-ZQruxkyB1p1MCFD8c8k9o/AzDOwKJ3cv7tf5D2C6pfR/HEVofXGRS9r9HE6GDUD23Ajt4novCEMf+SnJotJGIQ==" crossorigin=anonymous defer></script>
<script src=/js/highlight.min.3f0a703c54cbed82ca277187e23cf2d272da28c15ce7e33cde685d40b53d741893d5b74d35bb2d20a81f56c289084f245bdd0c9145d39d7094d3dfbc62d1326a.js integrity="sha512-PwpwPFTL7YLKJ3GH4jzy0nLaKMFc5+M83mhdQLU9dBiT1bdNNbstIKgfVsKJCE8kW90MkUXTnXCU09+8YtEyag==" crossorigin=anonymous defer></script>
<script src=/main.min.cb2e2ebbf2e4002f3117addc33582923b2b3ae5265c22944cd117ebec7abe61c170417c4506d7a0f8f0fc9053dfdf441421d53601ac467042ff3d06ec0ba07fa.js integrity="sha512-yy4uu/LkAC8xF63cM1gpI7KzrlJlwilEzRF+vser5hwXBBfEUG16D48PyQU9/fRBQh1TYBrEZwQv89BuwLoH+g==" crossorigin=anonymous defer></script>
<script src=/index.min.787928e0a959255366c62acb9b16d4f1f63336c0a411a3ec7059e7a5a0b8b9ab24a81b179d154bba8a6722d844ce2a02f730b853a8498e70bdeb258d1cbc7fde.js integrity="sha512-eHko4KlZJVNmxirLmxbU8fYzNsCkEaPscFnnpaC4uaskqBsXnRVLuopnIthEzioC9zC4U6hJjnC96yWNHLx/3g==" crossorigin=anonymous defer></script></body></html>